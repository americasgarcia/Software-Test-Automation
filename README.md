  Throughout this course, I've learned how important it is to make sure my code is both functional and secure. I do this by writing unit tests that cover not only the normal cases but also the edge cases that could cause errors. Running tests often helps me catch issues early and gives me confidence that my program works the way it should. I also focus on validation and error handling to make sure my software can handle unexpected inputs safely without breaking or exposing vulnerabilities. 
  
  When it comes to understanding user needs, I've also learned that it's all about turning requirements into clear and testable rules. For example, in my contact and task services, I took what the user needed, like unique IDs, and limited character lengths, and proper data formats and built those needs directly into my code's logic. Writing tests for each requirement helped me confirm that the program met those expectations. This process taught me to think like both a developer and a user, making sure my code doesn't just function but actually solves the problem it was meant to. 
  
  My approach to designing software now starts with keeping things organized and simple to maintain. I break the project into smaller classes that each have a specific purpose, and I think about how data will flow between them before I start coding. I've realized that testing isn't something to add at the end , it's part of the whole design itself. Writing clean code with testing in mind makes it easier to catch errors and make changes later without breaking anything. This course has taught me how to be more confident in creating reliable and test-driven software that will align with user needs. 
